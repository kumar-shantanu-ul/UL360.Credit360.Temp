-- Please update version.sql too -- this keeps clean builds in sync
define version=880
@update_header


CREATE TABLE CSR.QS_QUESTION_REPORT(
    APP_SID                  NUMBER(10, 0)    DEFAULT SYS_CONTEXT('SECURITY','APP') NOT NULL,
    QS_QUESTION_REPORT_ID    NUMBER(10, 0)    NOT NULL,
    QUESTION_ID              NUMBER(10, 0)    NOT NULL,
    COMPOUND_FILTER_SID      NUMBER(10, 0),
    DESCRIPTION              VARCHAR2(255)    NOT NULL,
    QS_CAMPAIGN_SID          NUMBER(10, 0),
    CONSTRAINT PK_QS_REPORT PRIMARY KEY (APP_SID, QS_QUESTION_REPORT_ID)
)
;

ALTER TABLE CSR.QUICK_SURVEY ADD (
    AGGREGATE_IND_GROUP_ID    NUMBER(10, 0),
    QUICK_SURVEY_TYPE_ID      NUMBER(10, 0),
    ROOT_IND_SID              NUMBER(10, 0)
)
;

ALTER TABLE CSR.QS_FILTER_CONDITION DROP CONSTRAINT FK_QS_FIL_COND_CMP_QN
;

ALTER TABLE CSR.QS_FILTER_CONDITION DROP COLUMN COMPARE_TO_QUESTION_ID
;

ALTER TABLE CSR.QS_CAMPAIGN ADD (
    PERIOD_START_DTM    DATE,
    PERIOD_END_DTM      DATE,
    CONSTRAINT CHK_PERIOD_DATES CHECK ((period_start_dtm IS NULL AND period_end_dtm IS NULL) OR period_start_dtm < period_end_dtm)
);

CREATE TABLE CSR.QUICK_SURVEY_TYPE(
    APP_SID                 NUMBER(10, 0)    DEFAULT SYS_CONTEXT('SECURITY','APP') NOT NULL,
    QUICK_SURVEY_TYPE_ID    NUMBER(10, 0)    NOT NULL,
    DESCRIPTION             VARCHAR2(255)    NOT NULL,
    CS_CLASS                VARCHAR2(255)    NOT NULL,
    CONSTRAINT PK_QS_TYPE PRIMARY KEY (APP_SID, QUICK_SURVEY_TYPE_ID)
)
;

CREATE TABLE CSR.REGION_SURVEY_RESPONSE(
    APP_SID               NUMBER(10, 0)    DEFAULT SYS_CONTEXT('SECURITY','APP') NOT NULL,
    SURVEY_SID            NUMBER(10, 0)    NOT NULL,
    SURVEY_RESPONSE_ID    NUMBER(10, 0)    NOT NULL,
    REGION_SID            NUMBER(10, 0)    NOT NULL,
    PERIOD_START_DTM      DATE             NOT NULL,
    PERIOD_END_DTM        DATE             NOT NULL,
    CONSTRAINT PK_REGION_SURVEY_RESPONSE PRIMARY KEY (APP_SID, SURVEY_SID, REGION_SID, PERIOD_START_DTM),
    CONSTRAINT UQ_REG_SUR_RESP_RESP_ID  UNIQUE (APP_SID, SURVEY_RESPONSE_ID)
)
;

CREATE SEQUENCE CSR.QUICK_SURVEY_TYPE_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    NOMAXVALUE
    CACHE 20
    NOORDER
;

CREATE SEQUENCE CSR.QS_QUESTION_REPORT_ID_SEQ
    START WITH 1
    INCREMENT BY 1
    NOMINVALUE
    NOMAXVALUE
    CACHE 20
    NOORDER
;

ALTER TABLE CSR.SUPPLIER_SURVEY_RESPONSE DROP CONSTRAINT PK_SUPPLIER_SURVEY_RESPONSE DROP INDEX;

ALTER TABLE CSR.SUPPLIER_SURVEY_RESPONSE ADD (
    PERIOD_START_DTM      DATE             NULL,
    PERIOD_END_DTM        DATE             NULL
)
;

UPDATE CSR.SUPPLIER_SURVEY_RESPONSE SET PERIOD_START_DTM=TO_DATE('01-JAN-2011', 'dd-MON-yyyy');
UPDATE CSR.SUPPLIER_SURVEY_RESPONSE SET PERIOD_END_DTM=TO_DATE('01-JAN-2012', 'dd-MON-yyyy');

ALTER TABLE  CSR.SUPPLIER_SURVEY_RESPONSE MODIFY PERIOD_START_DTM NOT NULL;
ALTER TABLE  CSR.SUPPLIER_SURVEY_RESPONSE MODIFY PERIOD_END_DTM NOT NULL;

ALTER TABLE CSR.SUPPLIER_SURVEY_RESPONSE ADD (
    CONSTRAINT PK_SUPPLIER_SURVEY_RESPONSE PRIMARY KEY (APP_SID, SUPPLIER_SID, SURVEY_SID, PERIOD_START_DTM)
)
;

CREATE INDEX CSR.IX_QS_Q_REP_Q_ID ON CSR.QS_QUESTION_REPORT(APP_SID, QUESTION_ID)
;

CREATE INDEX CSR.IX_QS_Q_REP_FIL_SID ON CSR.QS_QUESTION_REPORT(APP_SID, COMPOUND_FILTER_SID)
;

CREATE INDEX CSR.IX_QS_Q_REP_CAMP_SID ON CSR.QS_QUESTION_REPORT(APP_SID, QS_CAMPAIGN_SID)
;


CREATE INDEX CSR.IX_QS_AGG_GRP_ID ON CSR.QUICK_SURVEY(APP_SID, AGGREGATE_IND_GROUP_ID)
;


CREATE INDEX CSR.IX_QS_TYPE_ID ON CSR.QUICK_SURVEY(APP_SID, QUICK_SURVEY_TYPE_ID)
;

CREATE INDEX CSR.IX_RQSR_SURV_RESP_ID ON CSR.REGION_SURVEY_RESPONSE(APP_SID, SURVEY_SID, SURVEY_RESPONSE_ID)
;

CREATE INDEX CSR.IX_RQSR_REG_SID ON CSR.REGION_SURVEY_RESPONSE(APP_SID, REGION_SID)
;

ALTER TABLE CSR.QS_QUESTION_REPORT ADD CONSTRAINT FK_QS_REP_Q_ID 
    FOREIGN KEY (APP_SID, QUESTION_ID)
    REFERENCES CSR.QUICK_SURVEY_QUESTION(APP_SID, QUESTION_ID)
;

GRANT SELECT, REFERENCES ON CHAIN.COMPOUND_FILTER TO CSR;

ALTER TABLE CSR.QS_QUESTION_REPORT ADD CONSTRAINT FK_QS_REP_FILT_SID 
    FOREIGN KEY (APP_SID, COMPOUND_FILTER_SID)
    REFERENCES CHAIN.COMPOUND_FILTER(APP_SID, COMPOUND_FILTER_SID)
;

ALTER TABLE CSR.QS_QUESTION_REPORT ADD CONSTRAINT FK_QS_Q_REP_CAMP_SID 
    FOREIGN KEY (APP_SID, QS_CAMPAIGN_SID)
    REFERENCES CSR.QS_CAMPAIGN(APP_SID, QS_CAMPAIGN_SID)
;

ALTER TABLE CSR.QUICK_SURVEY ADD CONSTRAINT FK_QS_AGG_IND_GRP 
    FOREIGN KEY (APP_SID, AGGREGATE_IND_GROUP_ID)
    REFERENCES CSR.AGGREGATE_IND_GROUP(APP_SID, AGGREGATE_IND_GROUP_ID)
;

ALTER TABLE CSR.QUICK_SURVEY ADD CONSTRAINT FK_QS_QST 
    FOREIGN KEY (APP_SID, QUICK_SURVEY_TYPE_ID)
    REFERENCES CSR.QUICK_SURVEY_TYPE(APP_SID, QUICK_SURVEY_TYPE_ID)
;

ALTER TABLE CSR.QUICK_SURVEY_TYPE ADD CONSTRAINT FK_QST_APP_SID 
    FOREIGN KEY (APP_SID)
    REFERENCES CSR.CUSTOMER(APP_SID)
;

ALTER TABLE CSR.REGION_SURVEY_RESPONSE ADD CONSTRAINT FK_REG_SURV_RESP_REG_SID 
    FOREIGN KEY (APP_SID, REGION_SID)
    REFERENCES CSR.REGION(APP_SID, REGION_SID)
;

ALTER TABLE CSR.REGION_SURVEY_RESPONSE ADD CONSTRAINT FK_REG_SURV_RESP_RESP_ID 
    FOREIGN KEY (APP_SID, SURVEY_SID, SURVEY_RESPONSE_ID)
    REFERENCES CSR.QUICK_SURVEY_RESPONSE(APP_SID, SURVEY_SID, SURVEY_RESPONSE_ID)
;

declare
	policy_already_exists exception;
	pragma exception_init(policy_already_exists, -28101);

	type t_tabs is table of varchar2(30);
	v_list t_tabs;
	v_null_list t_tabs;
begin	
	v_list := t_tabs(
		'QS_QUESTION_REPORT',
		'QS_QUESTION_OPTION',
		'QUICK_SURVEY_TYPE',
		'REGION_SURVEY_RESPONSE'
	);
	for i in 1 .. v_list.count loop
		declare
			v_name varchar2(30);
			v_i pls_integer default 1;
		begin
			loop
				begin
					if v_i = 1 then
						v_name := SUBSTR(v_list(i), 1, 23)||'_POLICY';
					else
						v_name := SUBSTR(v_list(i), 1, 21)||'_POLICY_'||v_i;
					end if;
					dbms_output.put_line('doing '||v_name);
				    dbms_rls.add_policy(
				        object_schema   => 'CSR',
				        object_name     => v_list(i),
				        policy_name     => v_name,
				        function_schema => 'CSR',
				        policy_function => 'appSidCheck',
				        statement_types => 'select, insert, update, delete',
				        update_check	=> true,
				        policy_type     => dbms_rls.context_sensitive );
				    -- dbms_output.put_line('done  '||v_name);
				  	exit;
				exception
					when policy_already_exists then
						v_i := v_i + 1;
				end;
			end loop;
		end;
	end loop;
end;
/

begin
	FOR r IN (
		SELECT qs.app_sid, qs.survey_sid, aig.aggregate_ind_group_id
		  FROM csr.quick_survey qs
		  JOIN csr.aggregate_ind_group aig ON qs.app_sid = aig.app_sid
		 WHERE aig.name = 'InternalAudit'
		   AND qs.audience = 'audit'
	) LOOP
		UPDATE csr.quick_survey
		   SET aggregate_ind_group_id = r.aggregate_ind_group_id
		 WHERE survey_sid = r.survey_sid
		   AND app_sid = r.app_sid;
	END LOOP;
end;
/

@..\audit_pkg
@..\campaign_pkg
@..\quick_survey_pkg

@..\audit_body
@..\campaign_body
@..\measure_body
@..\csr_data_body
@..\quick_survey_body
@..\stored_calc_datasource_body


@update_tail
